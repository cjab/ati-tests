#!/usr/bin/env ruby
# frozen_string_literal: true

# Console client for ATI Rage 128 test firmware
# Supports interactive mode with readline, completion, and history
# Also supports non-interactive mode for scripting

require 'fileutils'
require 'yaml'
require 'optparse'
require 'reline'
require_relative '../lib/connection'

# Default connection settings
DEFAULT_HOST = 'localhost'
DEFAULT_PORT = 9001
DEFAULT_BAUD = 115_200
DEFAULT_TIMEOUT = 120

# XDG directories
def xdg_state_home
  ENV['XDG_STATE_HOME'] || File.expand_path('~/.local/state')
end

def history_file
  dir = File.join(xdg_state_home, 'rage128')
  FileUtils.mkdir_p(dir) unless Dir.exist?(dir)
  File.join(dir, 'history')
rescue StandardError
  File.expand_path('~/.rage128_history')
end

def load_history
  path = history_file
  return unless File.exist?(path)

  File.readlines(path, chomp: true).each do |line|
    Reline::HISTORY << line
  end
rescue StandardError => e
  warn "Warning: Could not load history: #{e.message}"
end

def save_history
  path = history_file
  File.open(path, 'w') do |f|
    Reline::HISTORY.each { |line| f.puts(line) }
  end
rescue StandardError => e
  warn "Warning: Could not save history: #{e.message}"
end

# Load register names from YAML files for completion
def load_register_names
  yaml_dir = File.expand_path('../ati/registers', __dir__)
  common = load_register_file(File.join(yaml_dir, 'common.yaml'))
  r128 = load_register_file(File.join(yaml_dir, 'r128.yaml'), 'R128_')
  r100 = load_register_file(File.join(yaml_dir, 'r100.yaml'), 'R100_')
  [*common, *r128, *r100].uniq.sort
end

def load_register_file(file, prefix = '')
  data = YAML.safe_load_file(file, permitted_classes: [Symbol])
  unless data.is_a?(Hash) && data['registers'].is_a?(Hash)
    raise "Invalid register file at: #{file}"
  end

  data['registers'].keys.map { |k| "#{prefix}#{k}" }
end

# Command definitions for completion
COMMANDS = %w[
  r rx w vr vw pr pw clr mr t tl cce regs dump help ? info reboot
].freeze

SUBCOMMANDS = {
  'cce' => %w[init start stop r w status],
  'regs' => %w[save diff],
  'dump' => %w[screen vram]
}.freeze

# Console client
class Console
  def initialize(conn, registers: [], output_dir: '.', raw_mode: false, prompt_tag: nil)
    @conn = conn
    @output_dir = output_dir
    @raw_mode = raw_mode
    @prompt_tag = prompt_tag
    @registers = registers
    @tests = []
  end

  def interactive
    load_history

    @conn.drain
    fetch_chip_info
    fetch_test_names
    setup_completion

    print_banner
    tag = @prompt_tag ? " #{@prompt_tag}" : ''
    prompt = "#{@chip_family.downcase}#{tag} \e[36m▸\e[0m "
    puts 'Type ? for help, Tab for completion'

    loop do
      begin
        line = Reline.readline(prompt, true)
      rescue Interrupt
        puts
        next
      end

      break if line.nil?

      if line.strip.empty?
        Reline::HISTORY.pop
        next
      end

      if Reline::HISTORY.length > 1 && Reline::HISTORY[-2] == line
        Reline::HISTORY.pop
      end

      @conn.command(line) do |segment|
        case segment
        when TextSegment
          text = segment.data
          text = text.gsub(/\e\[[0-9;]*m/, '') if @raw_mode
          print text
          $stdout.flush
        when FileProgressSegment
          now = Process.clock_gettime(Process::CLOCK_MONOTONIC)
          if @last_progress.nil? || now - @last_progress >= 0.2
            @last_progress = now
            print "\r#{INDENT}#{spinner} Receiving #{segment.filename}: " \
                  "#{format_bytes(segment.bytes_received)}"
            $stdout.flush
          end
        when FileSegment
          @last_progress = nil
          print "\r\e[2K"
          save_file(segment)
        when ErrorSegment
          render_error(segment.data)
        end
      end
    end
  ensure
    save_history
  end

  def execute(cmd)
    @conn.drain
    @conn.command(cmd) do |segment|
      case segment
      when TextSegment
        text = segment.data
        text = text.gsub(/\e\[[0-9;]*m/, '') if @raw_mode
        print text
      when FileSegment
        save_file(segment)
      when ErrorSegment
        render_error(segment.data)
      end
    end
  end

  private

  def fetch_chip_info
    text, _ = @conn.command('info')

    if text =~ /Family:\s+\e\[36m(\w+)\e\[0m/
      @chip_family = $1
    elsif text =~ /Family:\s+(\w+)/
      @chip_family = $1
    else
      @chip_family = 'ATI'
    end

    if text =~ /Name:\s+\e\[36m(.+?)\e\[0m/
      @chip_name = $1
    elsif text =~ /Name:\s+(.+)$/
      @chip_name = $1.strip
    else
      @chip_name = @chip_family
    end
  rescue StandardError => e
    warn "Warning: Could not fetch chip info: #{e.message}"
    @chip_family = 'ATI'
    @chip_name = 'ATI'
  end

  def fetch_test_names
    text, _ = @conn.command('tl')
    @tests = text.lines.grep(/^\s+\S+\s+\[/).map do |line|
      line.strip.split(/\s+/).first
    end.compact
  rescue StandardError => e
    warn "Warning: Could not fetch test names: #{e.message}"
    @tests = []
  end

  def print_banner
    name = @chip_name
    width = name.length + 4
    puts "\e[36m╭#{'─' * width}╮\e[0m"
    puts "\e[36m│\e[0m  #{name}  \e[36m│\e[0m"
    puts "\e[36m╰#{'─' * width}╯\e[0m"
  end

  SPINNER_FRAMES = %w[⠋ ⠙ ⠹ ⠸ ⠼ ⠴ ⠦ ⠧ ⠇ ⠏].freeze

  def spinner
    @spin_idx = (@spin_idx || 0) + 1
    SPINNER_FRAMES[@spin_idx % SPINNER_FRAMES.length]
  end

  def format_bytes(bytes)
    if bytes >= 1_048_576
      format('%.1f MB', bytes / 1_048_576.0)
    elsif bytes >= 1024
      format('%.1f KB', bytes / 1024.0)
    else
      "#{bytes} B"
    end
  end

  INDENT = '    '
  BOX_WIDTH = 76 # 80 - 4 for indent
  CONTENT_WIDTH = BOX_WIDTH - 3 # 2 for │ borders, 1 for left padding

  def render_error(text)
    lines = text.lines.map(&:chomp)
    lines.reject!(&:empty?)
    return if lines.empty?

    if @raw_mode
      lines.each { |l| warn "#{INDENT}ERROR: #{l}" }
      return
    end

    wrapped = lines.flat_map { |l| word_wrap(l, CONTENT_WIDTH) }
    inner_width = BOX_WIDTH - 2 # space between │ and │
    red = "\e[31m"
    rst = "\e[0m"

    warn "#{INDENT}#{red}╭─ Error #{'─' * [inner_width - 8, 0].max}╮#{rst}"
    wrapped.each do |line|
      warn "#{INDENT}#{red}│#{rst} #{line.ljust(inner_width - 1)}#{red}│#{rst}"
    end
    warn "#{INDENT}#{red}╰#{'─' * inner_width}╯#{rst}"
  end

  def word_wrap(line, width)
    return [line] if line.length <= width

    result = []
    remaining = line

    while remaining.length > width
      # Find last space within width
      break_at = remaining.rindex(' ', width)

      if break_at.nil? || break_at.zero?
        # No space found — hard break
        result << remaining[0, width]
        remaining = remaining[width..]
      else
        result << remaining[0, break_at]
        remaining = remaining[(break_at + 1)..]
      end
    end

    result << remaining unless remaining.empty?
    result
  end

  TESTS_DIR = File.expand_path('..', __dir__)
  DIFF_RLE = File.join(__dir__, 'diff-rle')

  def save_file(segment)
    output_path = File.join(@output_dir, segment.filename)
    FileUtils.mkdir_p(File.dirname(output_path))
    File.binwrite(output_path, segment.rle_data)

    status = segment.crc_ok ? 'CRC OK' : 'CRC FAILED'
    warn "#{INDENT}Received: #{output_path} (#{format_bytes(segment.rle_data.bytesize)}, #{status})"

    auto_diff(segment.filename, output_path)
  end

  def auto_diff(filename, actual_path)
    return unless filename.start_with?('failed/') && filename.end_with?('.rle')

    fixture_name = File.basename(filename, '.rle')
    fixture_path = File.join(TESTS_DIR, 'fixtures', "#{fixture_name}.rle")
    return unless File.exist?(fixture_path)

    diff_dir = File.join(@output_dir, 'diffs')
    FileUtils.mkdir_p(diff_dir)
    diff_output = File.join(diff_dir, "#{fixture_name}_diff.png")
    system(DIFF_RLE, fixture_path, actual_path, '-o', diff_output,
           out: '/dev/null', err: '/dev/null')
    if File.exist?(diff_output)
      warn "#{INDENT}Diff: #{diff_output}"
      warn ''
    end
  end

  def setup_completion
    Reline.completion_proc = method(:complete)
    Reline.completion_append_character = ' '
    Reline.autocompletion = true

    Reline::Face.config(:completion_dialog) do |face|
      face.define :default, foreground: :white, background: :black
      face.define :enhanced, foreground: :black, background: :cyan
      face.define :scrollbar, foreground: :cyan, background: :black
    end
  end

  def complete(input)
    line = Reline.line_buffer
    words = line.split(/\s+/)

    if words.empty? || (words.length == 1 && !line.end_with?(' '))
      COMMANDS.grep(/^#{Regexp.escape(input)}/i)
    else
      complete_argument(words, input, line.end_with?(' '))
    end
  end

  def complete_argument(words, input, trailing_space)
    cmd = words[0].downcase
    arg_index = trailing_space ? words.length : words.length - 1

    if arg_index == 1 && SUBCOMMANDS.key?(cmd)
      SUBCOMMANDS[cmd].grep(/^#{Regexp.escape(input)}/i)
    elsif cmd == 't' && arg_index == 1
      @tests.grep(/^#{Regexp.escape(input)}/i)
    elsif %w[r rx w].include?(cmd) && arg_index == 1
      @registers.select { |r| r.start_with?(input.upcase) }
                .flat_map { |r| [r, r.downcase] }
    else
      []
    end
  end
end

# Parse command line options
options = {
  host: ENV['RAGE128_HOST'] || DEFAULT_HOST,
  port: (ENV['RAGE128_PORT'] || DEFAULT_PORT).to_i,
  device: ENV['RAGE128_DEVICE'],
  baud: DEFAULT_BAUD,
  timeout: DEFAULT_TIMEOUT,
  output_dir: '.',
  raw_mode: false
}

OptionParser.new do |opts|
  opts.banner = 'Usage: console [options] [command]'

  opts.on('-h', '--host HOST', "TCP host (default: #{DEFAULT_HOST})") do |h|
    options[:host] = h
  end

  opts.on('-p', '--port PORT', Integer, "TCP port (default: #{DEFAULT_PORT})") do |p|
    options[:port] = p
  end

  opts.on('-d', '--device DEVICE', 'Serial device (e.g., /dev/ttyUSB0)') do |d|
    options[:device] = d
  end

  opts.on('-b', '--baud RATE', Integer, "Baud rate (default: #{DEFAULT_BAUD})") do |b|
    options[:baud] = b
  end

  opts.on('-t', '--timeout SECS', Integer, "Timeout in seconds (default: #{DEFAULT_TIMEOUT})") do |t|
    options[:timeout] = t
  end

  opts.on('-o', '--output-dir DIR', 'Directory for captured files') do |d|
    options[:output_dir] = d
  end

  opts.on('-r', '--raw', 'Strip ANSI escape codes from output') do
    options[:raw_mode] = true
  end

  opts.on('--prompt TAG', 'Additional label shown in prompt') do |tag|
    options[:prompt_tag] = tag
  end

  opts.on('--help', 'Show this help') do
    puts opts
    exit
  end
end.parse!

registers = load_register_names

conn = if options[:device]
         Connection.serial(options[:device], options[:baud],
                           timeout: options[:timeout])
       else
         Connection.tcp(options[:host], options[:port],
                        timeout: options[:timeout])
       end

console = Console.new(conn,
                      registers: registers,
                      output_dir: options[:output_dir],
                      raw_mode: options[:raw_mode],
                      prompt_tag: options[:prompt_tag])

begin
  if ARGV.empty? && $stdin.tty?
    console.interactive
  elsif ARGV.any?
    console.execute(ARGV.join(' '))
  else
    console.execute($stdin.read.strip)
  end
ensure
  conn.close
end
