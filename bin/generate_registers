#!/usr/bin/env ruby
# frozen_string_literal: true

# Generate C code from registers.yaml
#
# Usage:
#   ./generate_registers                    # Output to stdout
#   ./generate_registers -o ati_regs_gen.h  # Output to file
#   ./generate_registers --check ati.h      # Check if file is up to date

require 'yaml'
require 'optparse'

SCRIPT_DIR = __dir__
YAML_PATH = File.join(SCRIPT_DIR, '..', 'registers.yaml')

def load_registers
  YAML.load_file(YAML_PATH)
end

def field_width(field)
  if field['bit']
    1
  elsif field['bits']
    lo, hi = field['bits']
    hi - lo + 1
  else
    raise "Field has neither 'bit' nor 'bits': #{field.inspect}"
  end
end

def field_shift(field)
  field['bit'] || field['bits'][0]
end

def generate_field_enums(reg_name, fields)
  return '' if fields.nil? || fields.empty?

  lines = []
  fields.each do |field_name, field|
    shift = field_shift(field)
    width = field_width(field)

    if width == 1
      # Single bit flag: NAME = (1u << bit)
      lines << "    #{field_name} = (1u << #{shift}),"
    else
      # Multi-bit field: NAME_SHIFT and NAME_MASK
      mask = ((1 << width) - 1) << shift
      lines << "    #{field_name}_SHIFT = #{shift},"
      lines << "    #{field_name}_MASK = 0x#{mask.to_s(16)}u,"
    end

    # Generate named values if present (pre-shifted, ready to OR)
    if field['values']
      field['values'].each do |value_name, value|
        # Prefix with field name to avoid collisions
        const_name = "#{field_name}_#{value_name}"
        shifted_value = value << shift
        if shifted_value > 9
          lines << "    #{const_name} = 0x#{shifted_value.to_s(16)}u,"
        else
          lines << "    #{const_name} = #{shifted_value}u,"
        end
      end
    end
  end

  lines.join("\n")
end

# Generate a value table for a field (if it has values)
def generate_value_table(field_name, field)
  return nil unless field['values'] && !field['values'].empty?

  table_name = "#{field_name.downcase}_values"
  lines = ["static const field_value_t #{table_name}[] = {"]

  field['values'].each do |value_name, value|
    lines << "    {\"#{value_name}\", #{value}},"
  end

  lines << '    {NULL, 0}'
  lines << '};'

  [table_name, lines.join("\n")]
end

# Generate all value tables for a register's fields
def generate_value_tables(reg_name, fields)
  return [] if fields.nil? || fields.empty?

  tables = []
  fields.each do |field_name, field|
    result = generate_value_table(field_name, field)
    tables << result[1] if result
  end
  tables
end

def generate_field_table(reg_name, fields)
  return 'NULL' if fields.nil? || fields.empty?

  table_name = "#{reg_name.downcase}_fields"
  lines = ["static const field_entry_t #{table_name}[] = {"]

  fields.each do |field_name, field|
    shift = field_shift(field)
    width = field_width(field)
    values_ptr = if field['values'] && !field['values'].empty?
                   "#{field_name.downcase}_values"
                 else
                   'NULL'
                 end
    lines << "    {\"#{field_name}\", #{shift}, #{width}, #{values_ptr}},"
  end

  lines << '    {NULL, 0, 0, NULL}'
  lines << '};'

  lines.join("\n")
end

def generate_c_code(data)
  output = []

  output << <<~HEADER
    // Auto-generated from registers.yaml - DO NOT EDIT
    // Generated by: bin/generate_registers
    //
    // This file contains register offset constants, field enums, and field tables
    // for the ATI Rage 128 Pro graphics controller.
    //
    // Field values are PRE-SHIFTED and can be ORed directly into register values.
    // Example: reg |= GMC_BRUSH_DATATYPE_SOLIDCOLOR | GMC_ROP3_SRCCOPY;

    #ifndef ATI_REGS_GEN_H
    #define ATI_REGS_GEN_H

    #include <stdint.h>
    #include <stddef.h>

    // Named value entry for multi-bit fields
    typedef struct {
        const char *name;
        uint32_t value;  // raw, unshifted value
    } field_value_t;

    // Field entry structure for REPL field display
    typedef struct {
        const char *name;
        uint8_t shift;
        uint8_t width;
        const field_value_t *values;  // NULL if no named values
    } field_entry_t;

  HEADER

  # Generate field enums
  output << '// ============================================================================'
  output << '// Field Constants'
  output << '// ============================================================================'
  output << ''

  data['registers'].each do |reg_name, reg|
    next unless reg['fields'] && !reg['fields'].empty?

    output << "// #{reg_name} fields"
    output << 'enum {'
    output << generate_field_enums(reg_name, reg['fields'])
    output << '};'
    output << ''
  end

  # Generate value tables (must come before field tables that reference them)
  output << '// ============================================================================'
  output << '// Field Value Tables (for REPL display of named values)'
  output << '// ============================================================================'
  output << ''

  data['registers'].each do |_reg_name, reg|
    next unless reg['fields'] && !reg['fields'].empty?

    value_tables = generate_value_tables(_reg_name, reg['fields'])
    value_tables.each do |table|
      output << table
      output << ''
    end
  end

  # Generate field tables
  output << '// ============================================================================'
  output << '// Field Tables (for REPL display)'
  output << '// ============================================================================'
  output << ''

  data['registers'].each do |reg_name, reg|
    next unless reg['fields'] && !reg['fields'].empty?

    output << generate_field_table(reg_name, reg['fields'])
    output << ''
  end

  # Generate register offset enum
  output << '// ============================================================================'
  output << '// Register Offsets'
  output << '// ============================================================================'
  output << ''
  output << 'enum {'

  data['registers'].each do |reg_name, reg|
    output << "    #{reg_name} = 0x#{reg['offset'].to_s(16)},"
  end

  output << '};'
  output << ''

  # Generate ATI_REGISTERS macro
  output << '// ============================================================================'
  output << '// ATI_REGISTERS X-macro'
  output << '// Used to generate read/write functions, register tables, etc.'
  output << '// X(func_name, const_name, offset, mode, fields)'
  output << '// ============================================================================'
  output << ''
  output << '#define ATI_REGISTERS \\'

  data['registers'].each_with_index do |(reg_name, reg), idx|
    mode = reg['mode'].upcase
    fields = reg['fields'] && !reg['fields'].empty? ? "#{reg_name.downcase}_fields" : 'NULL'
    last = idx == data['registers'].size - 1
    cont = last ? '' : ' \\'
    output << "  X(#{reg_name.downcase}, #{reg_name}, 0x#{reg['offset'].to_s(16)}, #{mode}, #{fields})#{cont}"
  end

  output << ''
  output << '#endif // ATI_REGS_GEN_H'

  output.join("\n")
end

def main
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Usage: #{$PROGRAM_NAME} [options]"

    opts.on('-o', '--output FILE', 'Write output to FILE') do |f|
      options[:output] = f
    end

    opts.on('-c', '--check FILE', 'Check if FILE is up to date') do |f|
      options[:check] = f
    end

    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit
    end
  end.parse!

  data = load_registers
  generated = generate_c_code(data)

  if options[:check]
    if File.exist?(options[:check])
      existing = File.read(options[:check])
      if existing == generated
        puts "#{options[:check]} is up to date"
        exit 0
      else
        warn "#{options[:check]} is out of date, regenerate with:"
        warn "  #{$PROGRAM_NAME} -o #{options[:check]}"
        exit 1
      end
    else
      warn "#{options[:check]} does not exist, generate with:"
      warn "  #{$PROGRAM_NAME} -o #{options[:check]}"
      exit 1
    end
  elsif options[:output]
    File.write(options[:output], generated)
    puts "Generated #{options[:output]}"
  else
    puts generated
  end
end

main if __FILE__ == $PROGRAM_NAME
