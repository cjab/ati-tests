#!/usr/bin/env ruby
# frozen_string_literal: true

# Generate C code from registers.yaml
#
# Usage:
#   ./generate_registers                    # Output to stdout
#   ./generate_registers -o ati_regs_gen.h  # Output to file
#   ./generate_registers --check ati.h      # Check if file is up to date

require 'yaml'
require 'optparse'

SCRIPT_DIR = __dir__
YAML_PATH = File.join(SCRIPT_DIR, '..', 'registers.yaml')

# Flag name to C constant mapping
FLAG_MAP = {
  'no_read' => 'FLAG_NO_READ',
  'no_write' => 'FLAG_NO_WRITE',
  'read_side_effects' => 'FLAG_READ_SIDE_EFFECTS',
  'indirect' => 'FLAG_INDIRECT',
  'reverse_engineered' => 'FLAG_REVERSE_ENGINEERED'
}.freeze

def load_registers
  YAML.load_file(YAML_PATH)
end

# Convert flags array to C expression
def flags_to_c(flags)
  return '0' if flags.nil? || flags.empty?

  # Validate flags
  flags.each do |flag|
    raise "Unknown flag '#{flag}'" unless FLAG_MAP.key?(flag)
  end

  # Check for contradictory combinations
  if flags.include?('no_read') && flags.include?('no_write')
    raise "Invalid flags: no_read + no_write makes register useless"
  end

  if flags.include?('no_read') && flags.include?('read_side_effects')
    warn "Warning: no_read + read_side_effects is contradictory (read_side_effects is meaningless)"
  end

  if flags.include?('no_read') && flags.include?('indirect')
    warn "Warning: no_read + indirect is contradictory (indirect is meaningless)"
  end

  flags.map { |f| FLAG_MAP[f] }.join(' | ')
end

def field_width(field)
  if field['bit']
    1
  elsif field['bits']
    lo, hi = field['bits']
    hi - lo + 1
  else
    raise "Field has neither 'bit' nor 'bits': #{field.inspect}"
  end
end

def field_shift(field)
  field['bit'] || field['bits'][0]
end

# Track emitted enum constants to detect duplicates
@emitted_enums = {}

def reset_emitted_enums
  @emitted_enums = {}
end

# Check for duplicate/conflicting enum definitions
# Returns true if this is a duplicate (should skip), raises on conflict
def check_enum_duplicate(name, value)
  if @emitted_enums.key?(name)
    if @emitted_enums[name] != value
      raise "Conflicting enum '#{name}': previously defined as 0x#{@emitted_enums[name].to_s(16)}, " \
            "now trying to define as 0x#{value.to_s(16)}"
    end
    # Same name and value - skip silently (legitimate mirror)
    return true
  end
  @emitted_enums[name] = value
  false
end

# Emit a single-bit flag: NAME = (1u << bit)
def emit_enum_bit(name, bit, lines)
  value = 1 << bit
  return if check_enum_duplicate(name, value)

  lines << "    #{name} = (1u << #{bit}),"
end

# Emit a shift constant: NAME_SHIFT = N
def emit_enum_shift(name, shift, lines)
  return if check_enum_duplicate(name, shift)

  lines << "    #{name} = #{shift},"
end

# Emit a mask constant: NAME_MASK = 0xNNNu
def emit_enum_mask(name, mask, lines)
  return if check_enum_duplicate(name, mask)

  lines << "    #{name} = 0x#{mask.to_s(16)}u,"
end

# Emit a pre-shifted value constant
def emit_enum_value(name, value, lines)
  return if check_enum_duplicate(name, value)

  if value > 9
    lines << "    #{name} = 0x#{value.to_s(16)}u,"
  else
    lines << "    #{name} = #{value}u,"
  end
end

def generate_field_enums(reg_name, fields, aliases = nil)
  return '' if (fields.nil? || fields.empty?) && (aliases.nil? || aliases.empty?)

  lines = []

  # Generate field constants
  unless fields.nil? || fields.empty?
    fields.each do |field_name, field|
      shift = field_shift(field)
      width = field_width(field)

      if width == 1
        # Single bit flag: NAME = (1u << bit)
        emit_enum_bit(field_name, shift, lines)
      else
        # Multi-bit field: NAME_SHIFT and NAME_MASK
        mask = ((1 << width) - 1) << shift
        emit_enum_shift("#{field_name}_SHIFT", shift, lines)
        emit_enum_mask("#{field_name}_MASK", mask, lines)
      end

      # Generate named values if present (pre-shifted, ready to OR)
      if field['values']
        field['values'].each do |value_name, value|
          # Prefix with field name to avoid collisions
          const_name = "#{field_name}_#{value_name}"
          shifted_value = value << shift
          emit_enum_value(const_name, shifted_value, lines)
        end
      end
    end
  end

  # Generate alias constants
  unless aliases.nil? || aliases.empty?
    lines << '    // Aliases'
    aliases.each do |alias_name, alias_def|
      shift = field_shift(alias_def)
      width = field_width(alias_def)

      if width == 1
        emit_enum_bit(alias_name, shift, lines)
      else
        mask = ((1 << width) - 1) << shift
        emit_enum_shift("#{alias_name}_SHIFT", shift, lines)
        emit_enum_mask("#{alias_name}_MASK", mask, lines)
      end
    end
  end

  lines.join("\n")
end

# Generate a value table for a field (if it has values)
def generate_value_table(field_name, field)
  return nil unless field['values'] && !field['values'].empty?

  table_name = "#{field_name.downcase}_values"
  lines = ["static const field_value_t #{table_name}[] = {"]

  field['values'].each do |value_name, value|
    lines << "    {\"#{value_name}\", #{value}},"
  end

  lines << '    {NULL, 0}'
  lines << '};'

  [table_name, lines.join("\n")]
end

# Generate all value tables for a register's fields
def generate_value_tables(reg_name, fields)
  return [] if fields.nil? || fields.empty?

  tables = []
  fields.each do |field_name, field|
    result = generate_value_table(field_name, field)
    tables << result[1] if result
  end
  tables
end

def generate_field_table(reg_name, fields, reserved = nil, unknown = nil)
  has_fields = fields && !fields.empty?
  has_unknown = unknown && !unknown.empty?
  has_reserved = reserved && !reserved.empty?
  return 'NULL' unless has_fields || has_unknown || has_reserved

  table_name = "#{reg_name.downcase}_fields"
  lines = ["static const field_entry_t #{table_name}[] = {"]

  # Add regular fields
  if has_fields
    fields.each do |field_name, field|
      shift = field_shift(field)
      width = field_width(field)
      field_flags = flags_to_c(field['flags'])
      values_ptr = if field['values'] && !field['values'].empty?
                     "#{field_name.downcase}_values"
                   else
                     'NULL'
                   end
      lines << "    {\"#{field_name}\", #{shift}, #{width}, #{field_flags}, #{values_ptr}},"
    end
  end

  # Add unknown fields
  if has_unknown
    unknown.each do |unk|
      shift = field_shift(unk)
      width = field_width(unk)
      lines << "    {\"(unknown)\", #{shift}, #{width}, 0, NULL},"
    end
  end

  # Add reserved fields
  if has_reserved
    reserved.each do |res|
      shift = field_shift(res)
      width = field_width(res)
      lines << "    {\"(reserved)\", #{shift}, #{width}, 0, NULL},"
    end
  end

  lines << '    {NULL, 0, 0, 0, NULL}'
  lines << '};'

  lines.join("\n")
end

def generate_alias_table(reg_name, aliases)
  return 'NULL' if aliases.nil? || aliases.empty?

  table_name = "#{reg_name.downcase}_aliases"
  lines = ["static const field_entry_t #{table_name}[] = {"]

  aliases.each do |alias_name, alias_def|
    shift = field_shift(alias_def)
    width = field_width(alias_def)
    lines << "    {\"#{alias_name}\", #{shift}, #{width}, 0, NULL},"
  end

  lines << '    {NULL, 0, 0, 0, NULL}'
  lines << '};'

  lines.join("\n")
end

def generate_c_code(data)
  reset_emitted_enums
  output = []

  output << <<~HEADER
    // Auto-generated from registers.yaml - DO NOT EDIT
    // Generated by: bin/generate_registers
    //
    // This file contains register offset constants, field enums, and field tables
    // for the ATI Rage 128 Pro graphics controller.
    //
    // Field values are PRE-SHIFTED and can be ORed directly into register values.
    // Example: reg |= GMC_BRUSH_DATATYPE_SOLIDCOLOR | GMC_ROP3_SRCCOPY;

    #ifndef ATI_REGS_GEN_H
    #define ATI_REGS_GEN_H

    #include <stdint.h>
    #include <stddef.h>

    // Named value entry for multi-bit fields
    typedef struct {
        const char *name;
        uint32_t value;  // raw, unshifted value
    } field_value_t;

    // Field entry structure for REPL field display
    typedef struct {
        const char *name;
        uint8_t shift;
        uint8_t width;
        uint8_t flags;
        const field_value_t *values;  // NULL if no named values
    } field_entry_t;

    // Flags (for registers and fields)
    enum {
        FLAG_NO_READ           = (1 << 0),  // Cannot be read (write-only)
        FLAG_NO_WRITE          = (1 << 1),  // Cannot be written (read-only)
        FLAG_READ_SIDE_EFFECTS = (1 << 2),  // Reading modifies hardware state
        FLAG_INDIRECT          = (1 << 3),  // Access requires index register set first
        FLAG_REVERSE_ENGINEERED = (1 << 4), // Discovered through hardware testing
    };

  HEADER

  # Generate field enums
  output << '// ============================================================================'
  output << '// Field Constants'
  output << '// ============================================================================'
  output << ''

  data['registers'].each do |reg_name, reg|
    has_fields = reg['fields'] && !reg['fields'].empty?
    has_aliases = reg['aliases'] && !reg['aliases'].empty?
    next unless has_fields || has_aliases

    output << "// #{reg_name} fields"
    output << 'enum {'
    output << generate_field_enums(reg_name, reg['fields'], reg['aliases'])
    output << '};'
    output << ''
  end

  # Generate value tables (must come before field tables that reference them)
  output << '// ============================================================================'
  output << '// Field Value Tables (for REPL display of named values)'
  output << '// ============================================================================'
  output << ''

  data['registers'].each do |_reg_name, reg|
    next unless reg['fields'] && !reg['fields'].empty?

    value_tables = generate_value_tables(_reg_name, reg['fields'])
    value_tables.each do |table|
      output << table
      output << ''
    end
  end

  # Generate field tables
  output << '// ============================================================================'
  output << '// Field Tables (for REPL display)'
  output << '// ============================================================================'
  output << ''

  data['registers'].each do |reg_name, reg|
    has_fields = reg['fields'] && !reg['fields'].empty?
    has_unknown = reg['unknown'] && !reg['unknown'].empty?
    has_reserved = reg['reserved'] && !reg['reserved'].empty?
    next unless has_fields || has_unknown || has_reserved

    output << generate_field_table(reg_name, reg['fields'], reg['reserved'], reg['unknown'])
    output << ''
  end

  # Generate alias tables
  output << '// ============================================================================'
  output << '// Alias Tables (for REPL display)'
  output << '// ============================================================================'
  output << ''

  data['registers'].each do |reg_name, reg|
    next unless reg['aliases'] && !reg['aliases'].empty?

    output << generate_alias_table(reg_name, reg['aliases'])
    output << ''
  end

  # Generate register offset enum
  output << '// ============================================================================'
  output << '// Register Offsets'
  output << '// ============================================================================'
  output << ''
  output << 'enum {'

  data['registers'].each do |reg_name, reg|
    output << "    #{reg_name} = 0x#{reg['offset'].to_s(16)},"
  end

  output << '};'
  output << ''

  # Generate ATI_REGISTERS macro
  output << '// ============================================================================'
  output << '// ATI_REGISTERS X-macro'
  output << '// Used to generate read/write functions, register tables, etc.'
  output << '// X(func_name, const_name, offset, flags, fields, aliases)'
  output << '// ============================================================================'
  output << ''
  output << '#define ATI_REGISTERS \\'

  data['registers'].each_with_index do |(reg_name, reg), idx|
    flags = flags_to_c(reg['flags'])
    has_fields = reg['fields'] && !reg['fields'].empty?
    has_reserved = reg['reserved'] && !reg['reserved'].empty?
    fields = (has_fields || has_reserved) ? "#{reg_name.downcase}_fields" : 'NULL'
    aliases = reg['aliases'] && !reg['aliases'].empty? ? "#{reg_name.downcase}_aliases" : 'NULL'
    last = idx == data['registers'].size - 1
    cont = last ? '' : ' \\'
    output << "  X(#{reg_name.downcase}, #{reg_name}, 0x#{reg['offset'].to_s(16)}, #{flags}, #{fields}, #{aliases})#{cont}"
  end

  output << ''
  output << '#endif // ATI_REGS_GEN_H'

  output.join("\n")
end

def main
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Usage: #{$PROGRAM_NAME} [options]"

    opts.on('-o', '--output FILE', 'Write output to FILE') do |f|
      options[:output] = f
    end

    opts.on('-c', '--check FILE', 'Check if FILE is up to date') do |f|
      options[:check] = f
    end

    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit
    end
  end.parse!

  data = load_registers
  generated = generate_c_code(data)

  if options[:check]
    if File.exist?(options[:check])
      existing = File.read(options[:check])
      if existing == generated
        puts "#{options[:check]} is up to date"
        exit 0
      else
        warn "#{options[:check]} is out of date, regenerate with:"
        warn "  #{$PROGRAM_NAME} -o #{options[:check]}"
        exit 1
      end
    else
      warn "#{options[:check]} does not exist, generate with:"
      warn "  #{$PROGRAM_NAME} -o #{options[:check]}"
      exit 1
    end
  elsif options[:output]
    File.write(options[:output], generated)
    puts "Generated #{options[:output]}"
  else
    puts generated
  end
end

main if __FILE__ == $PROGRAM_NAME
