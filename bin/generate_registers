#!/usr/bin/env ruby
# frozen_string_literal: true

# Generate C code from registers.yaml
#
# Usage:
#   ./generate_registers                    # Output to stdout
#   ./generate_registers -o ati_regs_gen.h  # Output to file
#   ./generate_registers --check ati.h      # Check if file is up to date

require 'yaml'
require 'optparse'

SCRIPT_DIR = __dir__
YAML_PATH = File.join(SCRIPT_DIR, '..', 'registers.yaml')

def load_registers
  YAML.load_file(YAML_PATH)
end

def field_width(field)
  if field['bit']
    1
  elsif field['bits']
    lo, hi = field['bits']
    hi - lo + 1
  else
    raise "Field has neither 'bit' nor 'bits': #{field.inspect}"
  end
end

def field_shift(field)
  field['bit'] || field['bits'][0]
end

def generate_field_enums(reg_name, fields)
  return '' if fields.nil? || fields.empty?

  lines = []
  fields.each do |field_name, field|
    shift = field_shift(field)
    width = field_width(field)

    if width == 1
      # Single bit flag: NAME = (1u << bit)
      lines << "    #{field_name} = (1u << #{shift}),"
    else
      # Multi-bit field: NAME_SHIFT and NAME_MASK
      mask = ((1 << width) - 1) << shift
      lines << "    #{field_name}_SHIFT = #{shift},"
      lines << "    #{field_name}_MASK = 0x#{mask.to_s(16)}u,"
    end

    # Generate named values if present (pre-shifted, ready to OR)
    if field['values']
      field['values'].each do |value_name, value|
        # Prefix with field name to avoid collisions
        const_name = "#{field_name}_#{value_name}"
        shifted_value = value << shift
        if shifted_value > 9
          lines << "    #{const_name} = 0x#{shifted_value.to_s(16)}u,"
        else
          lines << "    #{const_name} = #{shifted_value}u,"
        end
      end
    end
  end

  lines.join("\n")
end

def generate_field_table(reg_name, fields)
  return 'NULL' if fields.nil? || fields.empty?

  table_name = "#{reg_name.downcase}_fields"
  lines = ["static const field_entry_t #{table_name}[] = {"]

  fields.each do |field_name, field|
    shift = field_shift(field)
    width = field_width(field)
    lines << "    {\"#{field_name}\", #{shift}, #{width}},"
  end

  lines << '    {NULL, 0, 0}'
  lines << '};'

  lines.join("\n")
end

def generate_c_code(data)
  output = []

  output << <<~HEADER
    // Auto-generated from registers.yaml - DO NOT EDIT
    // Generated by: tools/generate_registers.rb
    //
    // This file contains register offset constants, field enums, and field tables
    // for the ATI Rage 128 Pro graphics controller.
    //
    // Field values are PRE-SHIFTED and can be ORed directly into register values.
    // Example: reg |= GMC_BRUSH_DATATYPE_SOLIDCOLOR | GMC_ROP3_SRCCOPY;

    #ifndef ATI_REGS_GEN_H
    #define ATI_REGS_GEN_H

    #include <stdint.h>
    #include <stddef.h>

    // Field entry structure for REPL field display
    // (Must match definition in ati.h if used there)
    typedef struct {
        const char *name;
        uint8_t shift;
        uint8_t width;
    } field_entry_t;

  HEADER

  # Generate field enums
  output << '// ============================================================================'
  output << '// Field Constants'
  output << '// ============================================================================'
  output << ''

  data['registers'].each do |reg_name, reg|
    next unless reg['fields'] && !reg['fields'].empty?

    output << "// #{reg_name} fields"
    output << 'enum {'
    output << generate_field_enums(reg_name, reg['fields'])
    output << '};'
    output << ''
  end

  # Generate field tables
  output << '// ============================================================================'
  output << '// Field Tables (for REPL display)'
  output << '// ============================================================================'
  output << ''

  data['registers'].each do |reg_name, reg|
    next unless reg['fields'] && !reg['fields'].empty?

    output << generate_field_table(reg_name, reg['fields'])
    output << ''
  end

  # Generate register offset enum
  output << '// ============================================================================'
  output << '// Register Offsets'
  output << '// ============================================================================'
  output << ''
  output << 'enum {'

  data['registers'].each do |reg_name, reg|
    output << "    #{reg_name} = 0x#{reg['offset'].to_s(16)},"
  end

  output << '};'
  output << ''

  # Generate ATI_REGISTERS macro
  output << '// ============================================================================'
  output << '// ATI_REGISTERS X-macro'
  output << '// Used to generate read/write functions, register tables, etc.'
  output << '// X(func_name, const_name, offset, mode, fields)'
  output << '// ============================================================================'
  output << ''
  output << '#define ATI_REGISTERS \\'

  data['registers'].each_with_index do |(reg_name, reg), idx|
    mode = reg['mode'].upcase
    fields = reg['fields'] && !reg['fields'].empty? ? "#{reg_name.downcase}_fields" : 'NULL'
    last = idx == data['registers'].size - 1
    cont = last ? '' : ' \\'
    output << "  X(#{reg_name.downcase}, #{reg_name}, 0x#{reg['offset'].to_s(16)}, #{mode}, #{fields})#{cont}"
  end

  output << ''
  output << '#endif // ATI_REGS_GEN_H'

  output.join("\n")
end

def main
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Usage: #{$PROGRAM_NAME} [options]"

    opts.on('-o', '--output FILE', 'Write output to FILE') do |f|
      options[:output] = f
    end

    opts.on('-c', '--check FILE', 'Check if FILE is up to date') do |f|
      options[:check] = f
    end

    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit
    end
  end.parse!

  data = load_registers
  generated = generate_c_code(data)

  if options[:check]
    if File.exist?(options[:check])
      existing = File.read(options[:check])
      if existing == generated
        puts "#{options[:check]} is up to date"
        exit 0
      else
        warn "#{options[:check]} is out of date, regenerate with:"
        warn "  #{$PROGRAM_NAME} -o #{options[:check]}"
        exit 1
      end
    else
      warn "#{options[:check]} does not exist, generate with:"
      warn "  #{$PROGRAM_NAME} -o #{options[:check]}"
      exit 1
    end
  elsif options[:output]
    File.write(options[:output], generated)
    puts "Generated #{options[:output]}"
  else
    puts generated
  end
end

main if __FILE__ == $PROGRAM_NAME
