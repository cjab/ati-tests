#!/usr/bin/env ruby
# frozen_string_literal: true

# Generate C code from register YAML files
#
# Usage:
#   ./generate_registers --chip common -o common_regs_gen.h
#   ./generate_registers --chip r128 --prefix R128_ -o r128_regs_gen.h
#   ./generate_registers --chip r100 --prefix R100_ -o r100_regs_gen.h
#   ./generate_registers --chip common --check common_regs_gen.h

require 'yaml'
require 'optparse'

SCRIPT_DIR = __dir__
REGISTERS_DIR = File.join(SCRIPT_DIR, '..', 'ati', 'registers')

# Flag name to C constant mapping
FLAG_MAP = {
  'no_read' => 'FLAG_NO_READ',
  'no_write' => 'FLAG_NO_WRITE',
  'read_side_effects' => 'FLAG_READ_SIDE_EFFECTS',
  'indirect' => 'FLAG_INDIRECT',
  'reverse_engineered' => 'FLAG_REVERSE_ENGINEERED'
}.freeze

def load_registers(chip)
  yaml_path = File.join(REGISTERS_DIR, "#{chip}.yaml")
  unless File.exist?(yaml_path)
    raise "Register file not found: #{yaml_path}"
  end
  YAML.load_file(yaml_path)
end

# Convert flags array to C expression
def flags_to_c(flags)
  return '0' if flags.nil? || flags.empty?

  # Validate flags
  flags.each do |flag|
    raise "Unknown flag '#{flag}'" unless FLAG_MAP.key?(flag)
  end

  # Check for contradictory combinations
  if flags.include?('no_read') && flags.include?('no_write')
    raise "Invalid flags: no_read + no_write makes register useless"
  end

  if flags.include?('no_read') && flags.include?('read_side_effects')
    warn "Warning: no_read + read_side_effects is contradictory (read_side_effects is meaningless)"
  end

  if flags.include?('no_read') && flags.include?('indirect')
    warn "Warning: no_read + indirect is contradictory (indirect is meaningless)"
  end

  flags.map { |f| FLAG_MAP[f] }.join(' | ')
end

def field_width(field)
  if field['bit']
    1
  elsif field['bits']
    lo, hi = field['bits']
    hi - lo + 1
  else
    raise "Field has neither 'bit' nor 'bits': #{field.inspect}"
  end
end

def field_shift(field)
  field['bit'] || field['bits'][0]
end

# Track emitted enum constants to detect duplicates
@emitted_enums = {}

def reset_emitted_enums
  @emitted_enums = {}
end

# Check for duplicate/conflicting enum definitions
# Returns true if this is a duplicate (should skip), raises on conflict
def check_enum_duplicate(name, value)
  if @emitted_enums.key?(name)
    if @emitted_enums[name] != value
      raise "Conflicting enum '#{name}': previously defined as 0x#{@emitted_enums[name].to_s(16)}, " \
            "now trying to define as 0x#{value.to_s(16)}"
    end
    # Same name and value - skip silently (legitimate mirror)
    return true
  end
  @emitted_enums[name] = value
  false
end

# Emit a single-bit flag: NAME = (1u << bit)
def emit_enum_bit(name, bit, lines, prefix)
  value = 1 << bit
  full_name = "#{prefix}#{name}"
  return if check_enum_duplicate(full_name, value)

  lines << "    #{full_name} = (1u << #{bit}),"
end

# Emit a shift constant: NAME_SHIFT = N
def emit_enum_shift(name, shift, lines, prefix)
  full_name = "#{prefix}#{name}"
  return if check_enum_duplicate(full_name, shift)

  lines << "    #{full_name} = #{shift},"
end

# Emit a mask constant: NAME_MASK = 0xNNNu
def emit_enum_mask(name, mask, lines, prefix)
  full_name = "#{prefix}#{name}"
  return if check_enum_duplicate(full_name, mask)

  lines << "    #{full_name} = 0x#{mask.to_s(16)}u,"
end

# Emit a pre-shifted value constant
def emit_enum_value(name, value, lines, prefix)
  full_name = "#{prefix}#{name}"
  return if check_enum_duplicate(full_name, value)

  if value > 9
    lines << "    #{full_name} = 0x#{value.to_s(16)}u,"
  else
    lines << "    #{full_name} = #{value}u,"
  end
end

def generate_field_enums(reg_name, fields, aliases, prefix)
  return '' if (fields.nil? || fields.empty?) && (aliases.nil? || aliases.empty?)

  lines = []

  # Generate field constants
  unless fields.nil? || fields.empty?
    fields.each do |field_name, field|
      shift = field_shift(field)
      width = field_width(field)

      if width == 1
        # Single bit flag: NAME = (1u << bit)
        emit_enum_bit(field_name, shift, lines, prefix)
      else
        # Multi-bit field: NAME_SHIFT and NAME_MASK
        mask = ((1 << width) - 1) << shift
        emit_enum_shift("#{field_name}_SHIFT", shift, lines, prefix)
        emit_enum_mask("#{field_name}_MASK", mask, lines, prefix)
      end

      # Generate named values if present (pre-shifted, ready to OR)
      if field['values']
        field['values'].each do |value_name, value|
          # Prefix with field name to avoid collisions
          const_name = "#{field_name}_#{value_name}"
          shifted_value = value << shift
          emit_enum_value(const_name, shifted_value, lines, prefix)
        end
      end
    end
  end

  # Generate alias constants
  unless aliases.nil? || aliases.empty?
    lines << '    // Aliases'
    aliases.each do |alias_name, alias_def|
      shift = field_shift(alias_def)
      width = field_width(alias_def)

      if width == 1
        emit_enum_bit(alias_name, shift, lines, prefix)
      else
        mask = ((1 << width) - 1) << shift
        emit_enum_shift("#{alias_name}_SHIFT", shift, lines, prefix)
        emit_enum_mask("#{alias_name}_MASK", mask, lines, prefix)
      end
    end
  end

  lines.join("\n")
end

# Generate a value table for a field (if it has values)
def generate_value_table(field_name, field, prefix)
  return nil unless field['values'] && !field['values'].empty?

  table_name = "#{prefix.downcase}#{field_name.downcase}_values"
  lines = ["static const field_value_t #{table_name}[] = {"]

  field['values'].each do |value_name, value|
    lines << "    {\"#{value_name}\", #{value}},"
  end

  lines << '    {NULL, 0}'
  lines << '};'

  [table_name, lines.join("\n")]
end

# Generate all value tables for a register's fields
def generate_value_tables(reg_name, fields, prefix)
  return [] if fields.nil? || fields.empty?

  tables = []
  fields.each do |field_name, field|
    result = generate_value_table(field_name, field, prefix)
    tables << result[1] if result
  end
  tables
end

def generate_field_table(reg_name, fields, reserved, unknown, prefix)
  has_fields = fields && !fields.empty?
  has_unknown = unknown && !unknown.empty?
  has_reserved = reserved && !reserved.empty?
  return 'NULL' unless has_fields || has_unknown || has_reserved

  table_name = "#{prefix.downcase}#{reg_name.downcase}_fields"
  lines = ["static const field_entry_t #{table_name}[] = {"]

  # Add regular fields
  if has_fields
    fields.each do |field_name, field|
      shift = field_shift(field)
      width = field_width(field)
      field_flags = flags_to_c(field['flags'])
      values_ptr = if field['values'] && !field['values'].empty?
                     "#{prefix.downcase}#{field_name.downcase}_values"
                   else
                     'NULL'
                   end
      lines << "    {\"#{field_name}\", #{shift}, #{width}, #{field_flags}, #{values_ptr}},"
    end
  end

  # Add unknown fields
  if has_unknown
    unknown.each do |unk|
      shift = field_shift(unk)
      width = field_width(unk)
      lines << "    {\"(unknown)\", #{shift}, #{width}, 0, NULL},"
    end
  end

  # Add reserved fields
  if has_reserved
    reserved.each do |res|
      shift = field_shift(res)
      width = field_width(res)
      lines << "    {\"(reserved)\", #{shift}, #{width}, 0, NULL},"
    end
  end

  lines << '    {NULL, 0, 0, 0, NULL}'
  lines << '};'

  lines.join("\n")
end

def generate_alias_table(reg_name, aliases, prefix)
  return 'NULL' if aliases.nil? || aliases.empty?

  table_name = "#{prefix.downcase}#{reg_name.downcase}_aliases"
  lines = ["static const field_entry_t #{table_name}[] = {"]

  aliases.each do |alias_name, alias_def|
    shift = field_shift(alias_def)
    width = field_width(alias_def)
    lines << "    {\"#{alias_name}\", #{shift}, #{width}, 0, NULL},"
  end

  lines << '    {NULL, 0, 0, 0, NULL}'
  lines << '};'

  lines.join("\n")
end

def generate_c_code(data, chip, prefix)
  reset_emitted_enums
  output = []

  # Determine header guard and macro names based on chip
  guard_name = "#{prefix.upcase.gsub(/_$/, '')}_REGS_GEN_H"
  guard_name = "COMMON_REGS_GEN_H" if chip == 'common'
  
  macro_name = "#{prefix.upcase.gsub(/_$/, '')}_REGISTERS"
  macro_name = "COMMON_REGISTERS" if chip == 'common'

  chip_desc = case chip
              when 'common' then 'Common (shared between R128 and R100)'
              when 'r128' then 'ATI Rage 128 Pro specific'
              when 'r100' then 'ATI Radeon R100 (Mobility M6) specific'
              else chip
              end

  output << <<~HEADER
    // Auto-generated from registers/#{chip}.yaml - DO NOT EDIT
    // Generated by: bin/generate_registers --chip #{chip}#{prefix.empty? ? '' : " --prefix #{prefix}"}
    //
    // #{chip_desc} register definitions.
    //
    // Field values are PRE-SHIFTED and can be ORed directly into register values.
    // Example: reg |= #{prefix}GMC_BRUSH_DATATYPE_SOLIDCOLOR | #{prefix}GMC_ROP3_SRCCOPY;

    #ifndef #{guard_name}
    #define #{guard_name}

    #include <stdint.h>
    #include <stddef.h>

  HEADER

  # Only emit type definitions in common header to avoid redefinition
  if chip == 'common'
    output << <<~TYPES
    // Named value entry for multi-bit fields
    typedef struct {
        const char *name;
        uint32_t value;  // raw, unshifted value
    } field_value_t;

    // Field entry structure for REPL field display
    typedef struct {
        const char *name;
        uint8_t shift;
        uint8_t width;
        uint8_t flags;
        const field_value_t *values;  // NULL if no named values
    } field_entry_t;

    // Flags (for registers and fields)
    enum {
        FLAG_NO_READ           = (1 << 0),  // Cannot be read (write-only)
        FLAG_NO_WRITE          = (1 << 1),  // Cannot be written (read-only)
        FLAG_READ_SIDE_EFFECTS = (1 << 2),  // Reading modifies hardware state
        FLAG_INDIRECT          = (1 << 3),  // Access requires index register set first
        FLAG_REVERSE_ENGINEERED = (1 << 4), // Discovered through hardware testing
    };

    TYPES
  else
    output << "// Note: field_value_t, field_entry_t, and flag enums are defined in common_regs_gen.h\n"
    output << "#include \"common_regs_gen.h\"\n\n"
  end

  registers = data['registers'] || {}
  
  if registers.empty?
    # Empty register file - just emit empty macro
    output << "// No registers defined for #{chip}\n"
    output << "#define #{macro_name} /* empty */\n\n"
    output << "#endif // #{guard_name}\n"
    return output.join("\n")
  end

  # Generate field enums
  output << '// ============================================================================'
  output << '// Field Constants'
  output << '// ============================================================================'
  output << ''

  registers.each do |reg_name, reg|
    has_fields = reg['fields'] && !reg['fields'].empty?
    has_aliases = reg['aliases'] && !reg['aliases'].empty?
    next unless has_fields || has_aliases

    output << "// #{prefix}#{reg_name} fields"
    output << 'enum {'
    output << generate_field_enums(reg_name, reg['fields'], reg['aliases'], prefix)
    output << '};'
    output << ''
  end

  # Generate value tables (must come before field tables that reference them)
  output << '// ============================================================================'
  output << '// Field Value Tables (for REPL display of named values)'
  output << '// ============================================================================'
  output << ''

  registers.each do |_reg_name, reg|
    next unless reg['fields'] && !reg['fields'].empty?

    value_tables = generate_value_tables(_reg_name, reg['fields'], prefix)
    value_tables.each do |table|
      output << table
      output << ''
    end
  end

  # Generate field tables
  output << '// ============================================================================'
  output << '// Field Tables (for REPL display)'
  output << '// ============================================================================'
  output << ''

  registers.each do |reg_name, reg|
    has_fields = reg['fields'] && !reg['fields'].empty?
    has_unknown = reg['unknown'] && !reg['unknown'].empty?
    has_reserved = reg['reserved'] && !reg['reserved'].empty?
    next unless has_fields || has_unknown || has_reserved

    output << generate_field_table(reg_name, reg['fields'], reg['reserved'], reg['unknown'], prefix)
    output << ''
  end

  # Generate alias tables
  output << '// ============================================================================'
  output << '// Alias Tables (for REPL display)'
  output << '// ============================================================================'
  output << ''

  registers.each do |reg_name, reg|
    next unless reg['aliases'] && !reg['aliases'].empty?

    output << generate_alias_table(reg_name, reg['aliases'], prefix)
    output << ''
  end

  # Generate register offset enum
  output << '// ============================================================================'
  output << '// Register Offsets'
  output << '// ============================================================================'
  output << ''
  output << 'enum {'

  registers.each do |reg_name, reg|
    output << "    #{prefix}#{reg_name} = 0x#{reg['offset'].to_s(16)},"
  end

  output << '};'
  output << ''

  # Generate REGISTERS macro
  output << '// ============================================================================'
  output << "// #{macro_name} X-macro"
  output << '// Used to generate read/write functions, register tables, etc.'
  output << '// X(func_name, const_name, offset, flags, fields, aliases)'
  output << '// ============================================================================'
  output << ''
  output << "#define #{macro_name} \\"

  registers.each_with_index do |(reg_name, reg), idx|
    flags = flags_to_c(reg['flags'])
    has_fields = reg['fields'] && !reg['fields'].empty?
    has_reserved = reg['reserved'] && !reg['reserved'].empty?
    fields = (has_fields || has_reserved) ? "#{prefix.downcase}#{reg_name.downcase}_fields" : 'NULL'
    aliases = reg['aliases'] && !reg['aliases'].empty? ? "#{prefix.downcase}#{reg_name.downcase}_aliases" : 'NULL'
    last = idx == registers.size - 1
    cont = last ? '' : ' \\'
    func_prefix = prefix.downcase.gsub(/_$/, '_')
    func_prefix = '' if chip == 'common'
    output << "  X(#{func_prefix}#{reg_name.downcase}, #{prefix}#{reg_name}, 0x#{reg['offset'].to_s(16)}, #{flags}, #{fields}, #{aliases})#{cont}"
  end

  output << ''
  output << "#endif // #{guard_name}"

  output.join("\n")
end

def main
  options = { chip: nil, prefix: '', output: nil, check: nil }
  
  OptionParser.new do |opts|
    opts.banner = "Usage: #{$PROGRAM_NAME} [options]"

    opts.on('-c', '--chip CHIP', 'Chip type: common, r128, or r100 (required)') do |c|
      options[:chip] = c
    end

    opts.on('-p', '--prefix PREFIX', 'Prefix for constants (e.g., R128_)') do |p|
      options[:prefix] = p
    end

    opts.on('-o', '--output FILE', 'Write output to FILE') do |f|
      options[:output] = f
    end

    opts.on('--check FILE', 'Check if FILE is up to date') do |f|
      options[:check] = f
    end

    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit
    end
  end.parse!

  unless options[:chip]
    warn "Error: --chip is required (common, r128, or r100)"
    exit 1
  end

  unless %w[common r128 r100].include?(options[:chip])
    warn "Error: --chip must be common, r128, or r100"
    exit 1
  end

  data = load_registers(options[:chip])
  generated = generate_c_code(data, options[:chip], options[:prefix])

  if options[:check]
    if File.exist?(options[:check])
      existing = File.read(options[:check])
      if existing == generated
        puts "#{options[:check]} is up to date"
        exit 0
      else
        warn "#{options[:check]} is out of date, regenerate with:"
        warn "  #{$PROGRAM_NAME} --chip #{options[:chip]}#{options[:prefix].empty? ? '' : " --prefix #{options[:prefix]}"} -o #{options[:check]}"
        exit 1
      end
    else
      warn "#{options[:check]} does not exist, generate with:"
      warn "  #{$PROGRAM_NAME} --chip #{options[:chip]}#{options[:prefix].empty? ? '' : " --prefix #{options[:prefix]}"} -o #{options[:check]}"
      exit 1
    end
  elsif options[:output]
    File.write(options[:output], generated)
    puts "Generated #{options[:output]}"
  else
    puts generated
  end
end

main if __FILE__ == $PROGRAM_NAME
